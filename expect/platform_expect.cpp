/*
 * This file has been auto-generated by CppUMockGen v0.6.
 *
 * Contents will NOT be preserved if it is regenerated!!!
 */

#include "platform_expect.hpp"

namespace expect {
MockExpectedCall& panic_unsupported()
{
    return panic_unsupported(1);
}
MockExpectedCall& panic_unsupported(unsigned int __numCalls__)
{
    MockExpectedCall& __expectedCall__ = mock().expectNCalls(__numCalls__, "panic_unsupported");
    return __expectedCall__;
}
}

namespace expect {
MockExpectedCall& panic(CppUMockGen::Parameter<const char *> fmt)
{
    return panic(1, fmt);
}
MockExpectedCall& panic(unsigned int __numCalls__, CppUMockGen::Parameter<const char *> fmt)
{
    bool __ignoreOtherParams__ = false;
    MockExpectedCall& __expectedCall__ = mock().expectNCalls(__numCalls__, "panic");
    if(fmt.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withStringParameter("fmt", fmt.getValue()); }
    if(__ignoreOtherParams__) { __expectedCall__.ignoreOtherParameters(); }
    return __expectedCall__;
}
}

namespace expect {
MockExpectedCall& running_on_fpga(_Bool __return__)
{
    return running_on_fpga(1, __return__);
}
MockExpectedCall& running_on_fpga(unsigned int __numCalls__, _Bool __return__)
{
    MockExpectedCall& __expectedCall__ = mock().expectNCalls(__numCalls__, "running_on_fpga");
    __expectedCall__.andReturnValue(__return__);
    return __expectedCall__;
}
}

namespace expect {
MockExpectedCall& rp2040_chip_version(uint8_t __return__)
{
    return rp2040_chip_version(1, __return__);
}
MockExpectedCall& rp2040_chip_version(unsigned int __numCalls__, uint8_t __return__)
{
    MockExpectedCall& __expectedCall__ = mock().expectNCalls(__numCalls__, "rp2040_chip_version");
    __expectedCall__.andReturnValue(static_cast<unsigned int>(__return__));
    return __expectedCall__;
}
}

namespace expect {
MockExpectedCall& busy_wait_at_least_cycles(CppUMockGen::Parameter<uint32_t> minimum_cycles)
{
    return busy_wait_at_least_cycles(1, minimum_cycles);
}
MockExpectedCall& busy_wait_at_least_cycles(unsigned int __numCalls__, CppUMockGen::Parameter<uint32_t> minimum_cycles)
{
    bool __ignoreOtherParams__ = false;
    MockExpectedCall& __expectedCall__ = mock().expectNCalls(__numCalls__, "busy_wait_at_least_cycles");
    if(minimum_cycles.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withUnsignedIntParameter("minimum_cycles", minimum_cycles.getValue()); }
    if(__ignoreOtherParams__) { __expectedCall__.ignoreOtherParameters(); }
    return __expectedCall__;
}
}

namespace expect {
MockExpectedCall& get_core_num(uint __return__)
{
    return get_core_num(1, __return__);
}
MockExpectedCall& get_core_num(unsigned int __numCalls__, uint __return__)
{
    MockExpectedCall& __expectedCall__ = mock().expectNCalls(__numCalls__, "get_core_num");
    __expectedCall__.andReturnValue(static_cast<unsigned int>(__return__));
    return __expectedCall__;
}
}

namespace expect {
MockExpectedCall& rp2040_rom_version(uint8_t __return__)
{
    return rp2040_rom_version(1, __return__);
}
MockExpectedCall& rp2040_rom_version(unsigned int __numCalls__, uint8_t __return__)
{
    MockExpectedCall& __expectedCall__ = mock().expectNCalls(__numCalls__, "rp2040_rom_version");
    __expectedCall__.andReturnValue(static_cast<unsigned int>(__return__));
    return __expectedCall__;
}
}

namespace expect {
MockExpectedCall& tight_loop_contents()
{
    return tight_loop_contents(1);
}
MockExpectedCall& tight_loop_contents(unsigned int __numCalls__)
{
    MockExpectedCall& __expectedCall__ = mock().expectNCalls(__numCalls__, "tight_loop_contents");
    return __expectedCall__;
}
}


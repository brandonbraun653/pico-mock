/*
 * This file has been auto-generated by CppUMockGen v0.6.
 *
 * Contents will NOT be preserved if it is regenerated!!!
 */

#include "stdio_expect.hpp"

namespace expect {
MockExpectedCall& stdio_usb_init()
{
    return stdio_usb_init(1);
}
MockExpectedCall& stdio_usb_init(unsigned int __numCalls__)
{
    MockExpectedCall& __expectedCall__ = mock().expectNCalls(__numCalls__, "stdio_usb_init");
    return __expectedCall__;
}
}

namespace expect {
MockExpectedCall& stdio_uart_init()
{
    return stdio_uart_init(1);
}
MockExpectedCall& stdio_uart_init(unsigned int __numCalls__)
{
    MockExpectedCall& __expectedCall__ = mock().expectNCalls(__numCalls__, "stdio_uart_init");
    return __expectedCall__;
}
}

namespace expect {
MockExpectedCall& stdio_init_all()
{
    return stdio_init_all(1);
}
MockExpectedCall& stdio_init_all(unsigned int __numCalls__)
{
    MockExpectedCall& __expectedCall__ = mock().expectNCalls(__numCalls__, "stdio_init_all");
    return __expectedCall__;
}
}

namespace expect {
MockExpectedCall& stdio_filter_driver(stdio_driver_t * driver)
{
    return stdio_filter_driver(1, driver);
}
MockExpectedCall& stdio_filter_driver(unsigned int __numCalls__, stdio_driver_t * driver)
{
    MockExpectedCall& __expectedCall__ = mock().expectNCalls(__numCalls__, "stdio_filter_driver");
    __expectedCall__.withOutputParameterOfTypeReturning("stdio_driver_t", "driver", driver);
    return __expectedCall__;
}
}

namespace expect {
MockExpectedCall& stdio_set_translate_crlf(stdio_driver_t * driver, CppUMockGen::Parameter<_Bool> enabled)
{
    return stdio_set_translate_crlf(1, driver, enabled);
}
MockExpectedCall& stdio_set_translate_crlf(unsigned int __numCalls__, stdio_driver_t * driver, CppUMockGen::Parameter<_Bool> enabled)
{
    bool __ignoreOtherParams__ = false;
    MockExpectedCall& __expectedCall__ = mock().expectNCalls(__numCalls__, "stdio_set_translate_crlf");
    __expectedCall__.withOutputParameterOfTypeReturning("stdio_driver_t", "driver", driver);
    if(enabled.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withBoolParameter("enabled", enabled.getValue()); }
    if(__ignoreOtherParams__) { __expectedCall__.ignoreOtherParameters(); }
    return __expectedCall__;
}
}

namespace expect {
MockExpectedCall& stdio_usb_connected(_Bool __return__)
{
    return stdio_usb_connected(1, __return__);
}
MockExpectedCall& stdio_usb_connected(unsigned int __numCalls__, _Bool __return__)
{
    MockExpectedCall& __expectedCall__ = mock().expectNCalls(__numCalls__, "stdio_usb_connected");
    __expectedCall__.andReturnValue(__return__);
    return __expectedCall__;
}
}

namespace expect {
MockExpectedCall& getchar_timeout_us(CppUMockGen::Parameter<uint32_t> timeout_us, int __return__)
{
    return getchar_timeout_us(1, timeout_us, __return__);
}
MockExpectedCall& getchar_timeout_us(unsigned int __numCalls__, CppUMockGen::Parameter<uint32_t> timeout_us, int __return__)
{
    bool __ignoreOtherParams__ = false;
    MockExpectedCall& __expectedCall__ = mock().expectNCalls(__numCalls__, "getchar_timeout_us");
    if(timeout_us.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withUnsignedIntParameter("timeout_us", timeout_us.getValue()); }
    __expectedCall__.andReturnValue(__return__);
    if(__ignoreOtherParams__) { __expectedCall__.ignoreOtherParameters(); }
    return __expectedCall__;
}
}

